<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultPowerUnitRunnerImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Powerunit - Java Testing framework for JDK 1.8</a> &gt; <a href="index.source.html" class="el_package">ch.powerunit.impl</a> &gt; <span class="el_source">DefaultPowerUnitRunnerImpl.java</span></div><h1>DefaultPowerUnitRunnerImpl.java</h1><pre class="source lang-java linenums">/**
 * Powerunit - A JDK1.8 test framework
 * Copyright (C) 2014 Mathieu Boretti.
 *
 * This file is part of Powerunit
 *
 * Powerunit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Powerunit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Powerunit. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package ch.powerunit.impl;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import ch.powerunit.Categories;
import ch.powerunit.Ignore;
import ch.powerunit.Parameter;
import ch.powerunit.Parameters;
import ch.powerunit.PowerUnitRunner;
import ch.powerunit.Rule;
import ch.powerunit.Statement;
import ch.powerunit.Test;
import ch.powerunit.TestContext;
import ch.powerunit.TestDelegate;
import ch.powerunit.TestInterface;
import ch.powerunit.TestResultListener;
import ch.powerunit.TestRule;
import ch.powerunit.exception.AssumptionError;
import ch.powerunit.exception.InternalError;
import ch.powerunit.impl.validator.ParameterValidator;
import ch.powerunit.impl.validator.ParametersValidator;
import ch.powerunit.impl.validator.RuleValidator;
import ch.powerunit.impl.validator.TestDelegateValidator;
import ch.powerunit.impl.validator.TestValidator;

public class DefaultPowerUnitRunnerImpl&lt;T&gt; implements PowerUnitRunner&lt;T&gt;,
        ParametersValidator, ParameterValidator, TestValidator, RuleValidator,
        TestDelegateValidator {

<span class="fc" id="L64">    private final List&lt;TestResultListener&lt;Object&gt;&gt; listeners = new ArrayList&lt;&gt;();</span>

    private final String parentGroups;

    private final T targetObject;

    private final String setName;

    private final Method singleMethod;

    private final Object externalParameter;

    DefaultPowerUnitRunnerImpl(Class&lt;T&gt; testClass, Object externalParameter) {
<span class="fc" id="L77">        this(testClass, null, externalParameter);</span>
<span class="fc" id="L78">    }</span>

    public DefaultPowerUnitRunnerImpl(Class&lt;T&gt; testClass) {
<span class="fc" id="L81">        this(testClass, null);</span>
<span class="fc" id="L82">    }</span>

    public DefaultPowerUnitRunnerImpl(Class&lt;T&gt; testClass, Method singleMethod) {
<span class="fc" id="L85">        this(testClass, singleMethod, null);</span>
<span class="fc" id="L86">    }</span>

    DefaultPowerUnitRunnerImpl(Class&lt;T&gt; testClass, Method singleMethod,
<span class="fc" id="L89">            Object externalParameter) {</span>
<span class="fc" id="L90">        Objects.requireNonNull(testClass);</span>

<span class="fc" id="L92">        this.singleMethod = singleMethod;</span>
<span class="fc" id="L93">        this.setName = testClass.getName();</span>
<span class="fc" id="L94">        this.externalParameter = externalParameter;</span>
<span class="fc" id="L95">        Set&lt;String&gt; groups = findClass(testClass)</span>
<span class="fc" id="L96">                .stream()</span>
<span class="fc" id="L97">                .filter(c -&gt; c.isAnnotationPresent(Categories.class))</span>
<span class="fc" id="L98">                .map(c -&gt; Arrays.stream(</span>
<span class="fc" id="L99">                        c.getAnnotation(Categories.class).value()).collect(</span>
<span class="fc" id="L100">                        Collectors.toCollection(() -&gt; new HashSet&lt;&gt;())))</span>
<span class="fc" id="L101">                .reduce((o, n) -&gt; {</span>
<span class="nc" id="L102">                    o.addAll(n);</span>
<span class="nc" id="L103">                    return o;</span>
<span class="fc" id="L104">                }).orElse(new HashSet&lt;&gt;());</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        this.parentGroups = groups.isEmpty() ? TestResultListener.ALL_GROUPS</span>
<span class="fc" id="L106">                : Arrays.toString(groups.toArray());</span>

        try {
<span class="fc" id="L109">            targetObject = testClass.newInstance();</span>
<span class="fc" id="L110">        } catch (InstantiationException | IllegalAccessException e) {</span>
<span class="fc" id="L111">            throw new InternalError(&quot;Unexpected error &quot; + e.getMessage(), e);</span>
<span class="fc" id="L112">        }</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (testClass.isAnnotationPresent(Ignore.class)) {</span>
<span class="fc" id="L115">            executableTests.put(setName, p -&gt; {</span>
<span class="fc" id="L116">                TestContextImpl&lt;Object&gt; ctx = new TestContextImpl&lt;&gt;(</span>
                        targetObject, setName, setName, null, parentGroups);
<span class="fc" id="L118">                notifyStartTest(ctx);</span>
<span class="fc" id="L119">                notifyEndSkippedTest(ctx);</span>
<span class="fc" id="L120">            });</span>
<span class="fc" id="L121">            return;</span>
        }
<span class="fc" id="L123">        findTestsMethod(targetObject, testClass, parentGroups);</span>
<span class="fc" id="L124">        findTestsRule(targetObject, testClass);</span>
<span class="fc" id="L125">        findParametersMethod(targetObject, testClass);</span>
<span class="fc" id="L126">        findDelegateTest(targetObject, testClass);</span>
<span class="fc" id="L127">        computeExecutableStatements();</span>
<span class="fc" id="L128">        computeDelegateStatements();</span>
<span class="fc" id="L129">    }</span>

    @Override
    public void run() {
<span class="fc" id="L133">        notifyStartTests(setName, parentGroups);</span>
        try {
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (parameters != null) {</span>
<span class="fc" id="L136">                runAll();</span>
            } else {
<span class="fc" id="L138">                runOne(null);</span>
            }
        } finally {
<span class="pc" id="L141">            notifyEndTests(setName, parentGroups);</span>
<span class="fc" id="L142">        }</span>

<span class="fc" id="L144">    }</span>

    private void runAll() {
<span class="fc" id="L147">        testIndex = 0;</span>
<span class="pc bfc" id="L148" title="All 2 branches covered.">        try (Stream&lt;?&gt; params = (Stream&lt;?&gt;) (externalParameter == null ? parameters</span>
<span class="fc" id="L149">                .invoke(targetObject) : parameters.invoke(targetObject,</span>
                externalParameter))) {
<span class="fc" id="L151">            params.forEach(this::runOneParameter);</span>
<span class="pc bpc" id="L152" title="6 of 8 branches missed.">        } catch (IllegalAccessException | IllegalArgumentException</span>
                | InvocationTargetException e) {
<span class="nc" id="L154">            throw new InternalError(&quot;Unexpected error &quot; + e.getMessage(), e);</span>
<span class="fc" id="L155">        }</span>
<span class="fc" id="L156">    }</span>

<span class="fc" id="L158">    private int testIndex = 0;</span>

    private void runOneParameter(Object op) {
<span class="fc" id="L161">        String formatter = parameters.getAnnotation(Parameters.class).value();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (&quot;&quot;.equals(formatter)) {</span>
<span class="fc" id="L163">            formatter = &quot;&quot; + testIndex;</span>
        }
        Object o[];
<span class="pc bpc" id="L166" title="1 of 4 branches missed.">        if (op != null &amp;&amp; op.getClass().isArray()) {</span>
<span class="fc" id="L167">            o = (Object[]) op;</span>
        } else {
<span class="fc" id="L169">            o = new Object[] { op };</span>
        }
<span class="fc" id="L171">        String name = MessageFormat.format(formatter, o);</span>
        try {
<span class="fc" id="L173">            notifyStartParameter(setName, name);</span>
<span class="fc" id="L174">            int pidx = 0;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (o.length != parameterFields.size()) {</span>
<span class="nc" id="L176">                throw new InternalError(</span>
                        &quot;Parameter fields count doesn't match with array size returned by parameters&quot;);
            }
<span class="fc bfc" id="L179" title="All 2 branches covered.">            for (Object p : o) {</span>
                try {
<span class="fc" id="L181">                    Field f = parameterFields.get(pidx);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                    if (f == null) {</span>
<span class="nc" id="L183">                        throw new InternalError(&quot;Field &quot; + pidx</span>
                                + &quot; is not found&quot;);
                    }
<span class="fc" id="L186">                    f.set(targetObject, p);</span>
<span class="nc" id="L187">                } catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L188">                    throw new InternalError(&quot;Unexpected error &quot;</span>
<span class="nc" id="L189">                            + e.getMessage(), e);</span>
<span class="fc" id="L190">                }</span>
<span class="fc" id="L191">                pidx++;</span>
            }
<span class="fc" id="L193">            runOne(name, o);</span>
<span class="fc" id="L194">            testIndex++;</span>
        } finally {
<span class="pc" id="L196">            notifyEndParameter(setName, name);</span>
<span class="fc" id="L197">        }</span>
<span class="fc" id="L198">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void runOne(String name, Object... parameters) {
<span class="fc" id="L202">        executableTests</span>
<span class="fc" id="L203">                .entrySet()</span>
<span class="fc" id="L204">                .forEach(</span>
                        singleTest -&gt; {
                            try {
<span class="fc" id="L207">                                boolean run = true;</span>
<span class="fc" id="L208">                                String tname = singleTest.getKey();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                                if (filterParameterField != null) {</span>
<span class="fc" id="L210">                                    run = ((BiFunction&lt;String, Object, Boolean&gt;) filterParameterField</span>
<span class="fc" id="L211">                                            .get(targetObject)).apply(</span>
<span class="fc" id="L212">                                            testMethods.get(tname).getName(),</span>
                                            parameters);
                                }
<span class="fc bfc" id="L215" title="All 2 branches covered.">                                if (run) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                                    if (parameters.length &gt; 0) {</span>
<span class="fc" id="L217">                                        tname = MessageFormat.format(tname,</span>
                                                parameters);
                                    }
<span class="fc" id="L220">                                    singleTest.getValue().run(</span>
                                            new TestContextImpl&lt;Object&gt;(
                                                    targetObject, setName,
                                                    tname, name, parentGroups));
                                }
<span class="nc" id="L225">                            } catch (Throwable e) {// NOSONAR</span>
                                // As we really want all error
<span class="nc" id="L227">                                throw new InternalError(&quot;Unexpected error &quot;</span>
<span class="nc" id="L228">                                        + e.getMessage(), e);</span>
<span class="fc" id="L229">                            }</span>
<span class="fc" id="L230">                        });</span>
<span class="fc" id="L231">        delegateTests</span>
<span class="fc" id="L232">                .entrySet()</span>
<span class="fc" id="L233">                .forEach(</span>
                        singleTest -&gt; {
                            try {
<span class="fc" id="L236">                                boolean run = true;</span>
<span class="fc" id="L237">                                String tname = singleTest.getKey();</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                                if (filterParameterField != null) {</span>
<span class="nc" id="L239">                                    run = ((BiFunction&lt;String, Object, Boolean&gt;) filterParameterField</span>
<span class="nc" id="L240">                                            .get(targetObject)).apply(tname,</span>
                                            parameters);
                                }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                                if (run) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                                    if (parameters.length &gt; 0) {</span>
<span class="fc" id="L245">                                        tname = MessageFormat.format(tname,</span>
                                                parameters);
                                    }
<span class="fc" id="L248">                                    singleTest.getValue().run(</span>
                                            new TestContextImpl&lt;Object&gt;(
                                                    targetObject, setName,
                                                    tname, name, parentGroups));
                                }
<span class="nc" id="L253">                            } catch (Throwable e) {// NOSONAR</span>
                                // As we really want all error
<span class="nc" id="L255">                                throw new InternalError(&quot;Unexpected error &quot;</span>
<span class="nc" id="L256">                                        + e.getMessage(), e);</span>
<span class="fc" id="L257">                            }</span>
<span class="fc" id="L258">                        });</span>
<span class="fc" id="L259">    }</span>

<span class="fc" id="L261">    private final Map&lt;String, Method&gt; testMethods = new HashMap&lt;&gt;();</span>

<span class="fc" id="L263">    private TestRule testRules = null;</span>

<span class="fc" id="L265">    private Map&lt;String, Statement&lt;TestContext&lt;Object&gt;, Throwable&gt;&gt; executableTests = new HashMap&lt;&gt;();</span>

<span class="fc" id="L267">    private Map&lt;String, Statement&lt;TestContext&lt;Object&gt;, Throwable&gt;&gt; delegateTests = new HashMap&lt;&gt;();</span>

<span class="fc" id="L269">    private Method parameters = null;</span>

    private Map&lt;Integer, Field&gt; parameterFields;

<span class="fc" id="L273">    private Field filterParameterField = null;</span>

<span class="fc" id="L275">    private Map&lt;String, Supplier&lt;Object&gt;&gt; delegateTest = new HashMap&lt;&gt;();</span>

    private void findDelegateTest(T targetObject, Class&lt;T&gt; testClass) {
<span class="fc" id="L278">        findClass(testClass)</span>
<span class="fc" id="L279">                .stream()</span>
<span class="fc" id="L280">                .forEach(</span>
<span class="fc" id="L281">                        cls -&gt; Arrays</span>
<span class="fc" id="L282">                                .stream(cls.getDeclaredFields())</span>
<span class="fc" id="L283">                                .filter(f -&gt; f</span>
<span class="fc" id="L284">                                        .isAnnotationPresent(TestDelegate.class))</span>
<span class="fc" id="L285">                                .forEach(</span>
                                        f -&gt; {
<span class="fc" id="L287">                                            checkTestDelegateAnnotationForField(f);</span>
<span class="fc" id="L288">                                            if (Supplier.class</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                                                    .isAssignableFrom(f</span>
<span class="fc" id="L290">                                                            .getType())) {</span>
                                                try {
<span class="fc" id="L292">                                                    delegateTest.put(</span>
<span class="fc" id="L293">                                                            f.getName(),</span>
                                                            (Supplier&lt;Object&gt;) f
<span class="fc" id="L295">                                                                    .get(targetObject));</span>
<span class="fc" id="L296">                                                    return;</span>
<span class="nc" id="L297">                                                } catch (</span>
                                                        IllegalAccessException
                                                        | IllegalArgumentException e) {
<span class="nc" id="L300">                                                    throw new InternalError(</span>
                                                            &quot;Unexpected error &quot;
<span class="nc" id="L302">                                                                    + e.getMessage(),</span>
                                                            e);
                                                }
                                            }
<span class="fc" id="L306">                                            delegateTest.put(</span>
<span class="fc" id="L307">                                                    f.getName(),</span>
                                                    (Supplier&lt;Object&gt;) () -&gt; {
                                                        try {
<span class="fc" id="L310">                                                            return f.get(targetObject);</span>
<span class="nc" id="L311">                                                        } catch (</span>
                                                                IllegalAccessException
                                                                | IllegalArgumentException e) {
<span class="nc" id="L314">                                                            throw new InternalError(</span>
                                                                    &quot;Unexpected error &quot;
<span class="nc" id="L316">                                                                            + e.getMessage(),</span>
                                                                    e);
                                                        }
                                                    });
<span class="fc" id="L320">                                        }));</span>

<span class="fc" id="L322">    }</span>

    private void findParametersMethod(T targetObject, Class&lt;T&gt; testClass) {
<span class="fc" id="L325">        parameters = Arrays</span>
<span class="fc" id="L326">                .stream(testClass.getDeclaredMethods())</span>
<span class="fc" id="L327">                .filter(m -&gt; m.isAnnotationPresent(Parameters.class))</span>
<span class="fc" id="L328">                .peek(m -&gt; checkParametersAnnotationForMethod(m))</span>
<span class="fc" id="L329">                .reduce((o, n) -&gt; {</span>
<span class="fc" id="L330">                    throw new InternalError(</span>
                            &quot;@Parameters method can't only be once&quot;);
<span class="fc" id="L332">                }).orElse(null);</span>
<span class="fc" id="L333">        parameterFields = Arrays</span>
<span class="fc" id="L334">                .stream(testClass.getDeclaredFields())</span>
<span class="fc" id="L335">                .filter(f -&gt; f.isAnnotationPresent(Parameter.class))</span>
<span class="fc" id="L336">                .peek(f -&gt; {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                    if (parameters == null) {</span>
<span class="fc" id="L338">                        throw new InternalError(</span>
                                &quot;@Parameter can't be used without @Parameters method&quot;);
                    }
<span class="fc" id="L341">                })</span>
<span class="fc" id="L342">                .peek(f -&gt; checkParameterAnnotationForField(f))</span>
<span class="fc" id="L343">                .collect(</span>
                        Collectors
<span class="fc" id="L345">                                .&lt;Field, Integer, Field&gt; toMap(</span>
<span class="fc" id="L346">                                        (Field f) -&gt; f.getAnnotation(</span>
<span class="fc" id="L347">                                                Parameter.class).value(),</span>
<span class="fc" id="L348">                                        (Field f) -&gt; f,</span>
                                        (f1, f2) -&gt; {
<span class="fc" id="L350">                                            throw new InternalError(</span>
                                                    &quot;@Parameter can't be used twice with the same value number&quot;);
                                        }));
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (parameters != null) {</span>
            // assuming field numbering 0 to
<span class="fc" id="L355">            int size = parameterFields.size();</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (size == 0) {</span>
<span class="fc" id="L357">                throw new InternalError(&quot;No @Parameter field found&quot;);</span>
            }
<span class="fc" id="L359">            int expected = size * (size - 1) / 2;</span>
<span class="fc" id="L360">            int sum = parameterFields.keySet().stream().mapToInt(i -&gt; i).sum();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (sum != expected) {</span>
<span class="fc" id="L362">                throw new InternalError(</span>
                        &quot;@Parameter field number aren't continuus&quot;);
            }
<span class="fc" id="L365">            parameterFields</span>
<span class="fc" id="L366">                    .values()</span>
<span class="fc" id="L367">                    .stream()</span>
<span class="fc" id="L368">                    .forEach(</span>
                            f -&gt; {
<span class="fc" id="L370">                                Parameter p = f.getAnnotation(Parameter.class);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                                if (p.filter()) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                                    if (filterParameterField != null) {</span>
<span class="fc" id="L373">                                        throw new InternalError(</span>
                                                &quot;@Parameter filter attribute can only be used once per test class.&quot;);
                                    }
<span class="fc bfc" id="L376" title="All 2 branches covered.">                                    if (!BiFunction.class.isAssignableFrom(f</span>
<span class="fc" id="L377">                                            .getType())) {</span>
<span class="fc" id="L378">                                        throw new InternalError(</span>
                                                &quot;@Parameter filter attribute can only be use on BiFunction.&quot;);
                                    }
<span class="fc" id="L381">                                    filterParameterField = f;</span>

                                }
<span class="fc" id="L384">                            });</span>
        }
<span class="fc" id="L386">    }</span>

    private void findTestsMethod(T targetObject, Class&lt;T&gt; testClass,
            String parentGroup) {
<span class="fc" id="L390">        findClass(testClass).forEach(</span>
                cls -&gt; {
<span class="fc" id="L392">                    Arrays.stream(cls.getDeclaredMethods())</span>
<span class="fc" id="L393">                            .filter(m -&gt; m.isAnnotationPresent(Test.class))</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                            .filter(m -&gt; singleMethod == null</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">                                    || singleMethod.equals(m)).forEach(m -&gt; {</span>
<span class="fc" id="L396">                                checkTestAnnotationForMethod(m);</span>
<span class="fc" id="L397">                                Test annotation = m.getAnnotation(Test.class);</span>
<span class="fc" id="L398">                                String testName = m.getName();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                                if (!&quot;&quot;.equals(annotation.name())) {</span>
<span class="fc" id="L400">                                    testName = annotation.name();</span>
                                }
<span class="fc" id="L402">                                testMethods.put(testName, m);</span>
<span class="fc" id="L403">                            });</span>
<span class="fc" id="L404">                });</span>
<span class="fc" id="L405">    }</span>

    private void findTestsRule(T targetObject, Class&lt;T&gt; testClass) {
<span class="fc" id="L408">        testRules = findClass(testClass)</span>
<span class="fc" id="L409">                .stream()</span>
<span class="fc" id="L410">                .map(cls -&gt; Arrays</span>
<span class="fc" id="L411">                        .stream(cls.getDeclaredFields())</span>
<span class="fc" id="L412">                        .filter(f -&gt; f.isAnnotationPresent(Rule.class))</span>
<span class="fc" id="L413">                        .map(f -&gt; {</span>
<span class="fc" id="L414">                            checkRuleAnnotationForField(f);</span>
                            try {
<span class="fc" id="L416">                                TestRule tr1 = (TestRule) f.get(targetObject);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                                if (tr1 == null) {</span>
<span class="fc" id="L418">                                    throw new InternalError(</span>
                                            &quot;@Rule annotation is used on a null field. This is not allowed&quot;);
                                }
<span class="fc" id="L421">                                return tr1;</span>
<span class="nc" id="L422">                            } catch (IllegalAccessException</span>
                                    | IllegalArgumentException e) {
<span class="nc" id="L424">                                throw new InternalError(&quot;Unexpected error &quot;</span>
<span class="nc" id="L425">                                        + e.getMessage(), e);</span>
                            }
                        })
<span class="fc" id="L428">                        .reduce((o, n) -&gt; {</span>
<span class="fc" id="L429">                            throw new InternalError(</span>
                                    &quot;@Rule annotation can only be used once on field&quot;);
<span class="fc bfc" id="L431" title="All 2 branches covered.">                        }).orElse(null)).filter(i -&gt; i != null)</span>
<span class="fc" id="L432">                .reduce((o, n) -&gt; o.around(n)).orElse(null);</span>

<span class="fc" id="L434">    }</span>

    private List&lt;Class&lt;?&gt;&gt; findClass(Class&lt;T&gt; testClass) {
<span class="fc" id="L437">        List&lt;Class&lt;?&gt;&gt; clazzs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L438">        Class&lt;?&gt; current = testClass;</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        while (current != null) {</span>
<span class="fc" id="L440">            clazzs.add(0, current);</span>
<span class="fc" id="L441">            current = current.getSuperclass();</span>
        }
<span class="fc" id="L443">        return clazzs;</span>
    }

    private void computeExecutableStatements() {
<span class="fc" id="L447">        executableTests = testMethods</span>
<span class="fc" id="L448">                .entrySet()</span>
<span class="fc" id="L449">                .stream()</span>
<span class="fc" id="L450">                .collect(</span>
<span class="fc" id="L451">                        Collectors.toMap(</span>
<span class="fc" id="L452">                                test -&gt; test.getKey(),</span>
                                test -&gt; {
                                    Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; stest;
<span class="fc bfc" id="L455" title="All 2 branches covered.">                                    if (test.getValue().isAnnotationPresent(</span>
                                            Ignore.class)) {
<span class="fc" id="L457">                                        stest = p -&gt; {</span>
<span class="fc" id="L458">                                            throw new AssumptionError(</span>
                                                    &quot;Test method is annotated with @Ignore&quot;);
                                        };
                                    } else {
<span class="fc" id="L462">                                        Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; itest = p -&gt; {</span>
<span class="fc" id="L463">                                            Statement</span>
<span class="fc" id="L464">                                                    .&lt;TestContext&lt;Object&gt;, Throwable&gt; reflectionMethod(</span>
                                                            targetObject,
<span class="fc" id="L466">                                                            test.getValue())</span>
<span class="fc" id="L467">                                                    .run(p);</span>
<span class="fc" id="L468">                                        };</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                                        if (testRules != null) {</span>
<span class="fc" id="L470">                                            stest = p -&gt; testRules</span>
<span class="fc" id="L471">                                                    .computeStatement(itest)</span>
<span class="fc" id="L472">                                                    .run(p);</span>
                                        } else {
<span class="fc" id="L474">                                            stest = itest;</span>
                                        }

                                    }
<span class="fc" id="L478">                                    return p -&gt; {</span>
<span class="fc" id="L479">                                        notifyStartTest(p);</span>
                                        try {
<span class="fc" id="L481">                                            stest.run(p);</span>
<span class="fc" id="L482">                                            notifyEndSuccessTest(p);</span>
<span class="nc" id="L483">                                        } catch (InternalError e) {</span>
<span class="nc" id="L484">                                            notifyEndFailureTest(p, e);</span>
<span class="fc" id="L485">                                        } catch (AssertionError e) {</span>
<span class="fc" id="L486">                                            notifyEndFailureTest(p, e);</span>
<span class="fc" id="L487">                                        } catch (AssumptionError e) {</span>
<span class="fc" id="L488">                                            notifyEndSkippedTest(p);</span>
<span class="fc" id="L489">                                        } catch (Throwable e) {// NOSONAR</span>
                                            // As we really want all error
<span class="fc" id="L491">                                            notifyEndFailureTest(p, e);</span>
<span class="pc" id="L492">                                        }</span>
<span class="fc" id="L493">                                    };</span>
                                }));
<span class="fc" id="L495">    }</span>

    private void computeDelegateStatements() {
<span class="fc" id="L498">        delegateTests = delegateTest.entrySet().stream()</span>
<span class="fc" id="L499">                .collect(Collectors.toMap(test -&gt; test.getKey(), test -&gt; {</span>
                    Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; stest;
<span class="fc" id="L501">                    Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; itest = p -&gt; {</span>
<span class="fc" id="L502">                        new Statement&lt;TestContext&lt;Object&gt;, Throwable&gt;() {</span>

                            @Override
                            public void run(TestContext&lt;Object&gt; parameter)
                                    throws Throwable {
<span class="fc" id="L507">                                Supplier&lt;Object&gt; o = test.getValue();</span>
<span class="fc" id="L508">                                Object target = o.get();</span>
<span class="fc" id="L509">                                Class&lt;?&gt; delegator = target.getClass()</span>
<span class="fc" id="L510">                                        .getAnnotation(TestInterface.class)</span>
<span class="fc" id="L511">                                        .value();</span>
<span class="fc" id="L512">                                DefaultPowerUnitRunnerImpl&lt;?&gt; dpu = new DefaultPowerUnitRunnerImpl&lt;&gt;(</span>
                                        delegator, target);
<span class="fc" id="L514">                                dpu.addListener((TestResultListener) new DelegationTestResultListener(</span>
                                        parameter));
<span class="fc" id="L516">                                dpu.run();</span>
<span class="fc" id="L517">                            }</span>

                            @Override
                            public String getName() {
<span class="nc" id="L521">                                return test.getKey();</span>
                            }
<span class="fc" id="L523">                        }.run(p);</span>
<span class="fc" id="L524">                    };</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                    if (testRules != null) {</span>
<span class="nc" id="L526">                        stest = p -&gt; testRules.computeStatement(itest).run(p);</span>
                    } else {
<span class="fc" id="L528">                        stest = itest;</span>
                    }

<span class="fc" id="L531">                    return p -&gt; {</span>
                        try {
<span class="fc" id="L533">                            stest.run(p);</span>
<span class="nc" id="L534">                        } catch (InternalError e) {</span>
<span class="nc" id="L535">                            notifyStartTest(p);</span>
<span class="nc" id="L536">                            notifyEndFailureTest(p, e);</span>
<span class="nc" id="L537">                        } catch (AssertionError e) {</span>
<span class="nc" id="L538">                            notifyStartTest(p);</span>
<span class="nc" id="L539">                            notifyEndFailureTest(p, e);</span>
<span class="nc" id="L540">                        } catch (AssumptionError e) {</span>
<span class="nc" id="L541">                            notifyStartTest(p);</span>
<span class="nc" id="L542">                            notifyEndSkippedTest(p);</span>
<span class="nc" id="L543">                        } catch (Throwable e) {// NOSONAR</span>
                            // As we really want all error
<span class="nc" id="L545">                            notifyStartTest(p);</span>
<span class="nc" id="L546">                            notifyEndFailureTest(p, e);</span>
<span class="pc" id="L547">                        }</span>
<span class="fc" id="L548">                    };</span>
                }));
<span class="fc" id="L550">    }</span>

    @Override
    public void addListener(TestResultListener&lt;T&gt; listener) {
<span class="fc" id="L554">        listeners.add((TestResultListener) listener);</span>
<span class="fc" id="L555">    }</span>

    private void notifyStartTests(String setName, String groups) {
<span class="fc" id="L558">        listeners.forEach(trl -&gt; trl.notifySetStart(setName, groups));</span>
<span class="fc" id="L559">    }</span>

    private void notifyEndTests(String setName, String groups) {
<span class="fc" id="L562">        listeners.forEach(trl -&gt; trl.notifySetEnd(setName, groups));</span>
<span class="fc" id="L563">    }</span>

    private void notifyStartParameter(String setName, String parameterName) {
<span class="fc" id="L566">        listeners.forEach(trl -&gt; trl.notifyParameterStart(setName,</span>
                parameterName));
<span class="fc" id="L568">    }</span>

    private void notifyEndParameter(String setName, String parameterName) {
<span class="fc" id="L571">        listeners</span>
<span class="fc" id="L572">                .forEach(trl -&gt; trl.notifyParameterEnd(setName, parameterName));</span>
<span class="fc" id="L573">    }</span>

    private void notifyStartTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L576">        listeners.forEach(trl -&gt; trl.notifyStart(context));</span>
<span class="fc" id="L577">    }</span>

    private void notifyEndSuccessTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L580">        listeners.forEach(trl -&gt; trl.notifySuccess(context));</span>
<span class="fc" id="L581">    }</span>

    private void notifyEndSkippedTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L584">        listeners.forEach(trl -&gt; trl.notifySkipped(context));</span>
<span class="fc" id="L585">    }</span>

    private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
            AssertionError cause) {
<span class="fc" id="L589">        listeners.forEach(trl -&gt; trl.notifyFailure(context, cause));</span>
<span class="fc" id="L590">    }</span>

    private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
            InternalError cause) {
<span class="nc" id="L594">        listeners.forEach(trl -&gt; trl.notifyError(context, cause));</span>
<span class="nc" id="L595">    }</span>

    private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
            Throwable cause) {
<span class="fc" id="L599">        listeners.forEach(trl -&gt; trl.notifyError(context, cause));</span>
<span class="fc" id="L600">    }</span>

    private class DelegationTestResultListener implements
            TestResultListener&lt;Object&gt; {

        private final TestContext&lt;Object&gt; parentContext;

<span class="fc" id="L607">        public DelegationTestResultListener(TestContext&lt;Object&gt; parentContext) {</span>
<span class="fc" id="L608">            this.parentContext = parentContext;</span>
<span class="fc" id="L609">        }</span>

        @Override
        public void notifySetStart(String setName, String groups) {
            // ignore
<span class="fc" id="L614">        }</span>

        @Override
        public void notifySetEnd(String setName, String groups) {
            // ignore
<span class="fc" id="L619">        }</span>

        @Override
        public void notifyStart(TestContext&lt;Object&gt; context) {
<span class="fc" id="L623">            TestContext&lt;Object&gt; ctx = new TestContextImpl&lt;Object&gt;(</span>
<span class="fc" id="L624">                    parentContext.getTestSuiteObject(),</span>
<span class="fc" id="L625">                    parentContext.getSetName(), context.getLocalTestName(),</span>
<span class="fc" id="L626">                    parentContext.getParameterName(),</span>
<span class="fc" id="L627">                    parentContext.getTestCategories());</span>
<span class="fc" id="L628">            notifyStartTest(ctx);</span>
<span class="fc" id="L629">        }</span>

        @Override
        public void notifySuccess(TestContext&lt;Object&gt; context) {
<span class="fc" id="L633">            TestContext&lt;Object&gt; ctx = new TestContextImpl&lt;Object&gt;(</span>
<span class="fc" id="L634">                    parentContext.getTestSuiteObject(),</span>
<span class="fc" id="L635">                    parentContext.getSetName(), context.getLocalTestName(),</span>
<span class="fc" id="L636">                    parentContext.getParameterName(),</span>
<span class="fc" id="L637">                    parentContext.getTestCategories());</span>
<span class="fc" id="L638">            notifyEndSuccessTest(ctx);</span>
<span class="fc" id="L639">        }</span>

        @Override
        public void notifyFailure(TestContext&lt;Object&gt; context, Throwable cause) {
<span class="nc" id="L643">            TestContext&lt;Object&gt; ctx = new TestContextImpl&lt;Object&gt;(</span>
<span class="nc" id="L644">                    parentContext.getTestSuiteObject(),</span>
<span class="nc" id="L645">                    parentContext.getSetName(), context.getLocalTestName(),</span>
<span class="nc" id="L646">                    parentContext.getParameterName(),</span>
<span class="nc" id="L647">                    parentContext.getTestCategories());</span>
<span class="nc" id="L648">            notifyEndFailureTest(ctx, (AssertionError) cause);</span>
<span class="nc" id="L649">        }</span>

        @Override
        public void notifyError(TestContext&lt;Object&gt; context, Throwable cause) {
<span class="nc" id="L653">            TestContext&lt;Object&gt; ctx = new TestContextImpl&lt;Object&gt;(</span>
<span class="nc" id="L654">                    parentContext.getTestSuiteObject(),</span>
<span class="nc" id="L655">                    parentContext.getSetName(), context.getLocalTestName(),</span>
<span class="nc" id="L656">                    parentContext.getParameterName(),</span>
<span class="nc" id="L657">                    parentContext.getTestCategories());</span>
<span class="nc" id="L658">            notifyEndFailureTest(ctx, cause);</span>
<span class="nc" id="L659">        }</span>

        @Override
        public void notifySkipped(TestContext&lt;Object&gt; context) {
<span class="nc" id="L663">            TestContext&lt;Object&gt; ctx = new TestContextImpl&lt;Object&gt;(</span>
<span class="nc" id="L664">                    parentContext.getTestSuiteObject(),</span>
<span class="nc" id="L665">                    parentContext.getSetName(), context.getLocalTestName(),</span>
<span class="nc" id="L666">                    parentContext.getParameterName(),</span>
<span class="nc" id="L667">                    parentContext.getTestCategories());</span>
<span class="nc" id="L668">            notifyEndSkippedTest(ctx);</span>
<span class="nc" id="L669">        }</span>

        @Override
        public void notifyParameterStart(String setName, String parameterName) {
            // ignore
<span class="fc" id="L674">        }</span>

        @Override
        public void notifyParameterEnd(String setName, String parameterName) {
            // ignore
<span class="fc" id="L679">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>