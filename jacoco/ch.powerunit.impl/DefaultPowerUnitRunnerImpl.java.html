<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultPowerUnitRunnerImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Powerunit - Java Testing framework for JDK 1.8</a> &gt; <a href="index.source.html" class="el_package">ch.powerunit.impl</a> &gt; <span class="el_source">DefaultPowerUnitRunnerImpl.java</span></div><h1>DefaultPowerUnitRunnerImpl.java</h1><pre class="source lang-java linenums">/**
 * Powerunit - A JDK1.8 test framework
 * Copyright (C) 2014 Mathieu Boretti.
 *
 * This file is part of Powerunit
 *
 * Powerunit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Powerunit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Powerunit. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package ch.powerunit.impl;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import ch.powerunit.Categories;
import ch.powerunit.Ignore;
import ch.powerunit.Parameter;
import ch.powerunit.Parameters;
import ch.powerunit.PowerUnitRunner;
import ch.powerunit.Rule;
import ch.powerunit.Statement;
import ch.powerunit.Test;
import ch.powerunit.TestContext;
import ch.powerunit.TestResultListener;
import ch.powerunit.TestRule;
import ch.powerunit.exception.AssumptionError;
import ch.powerunit.exception.InternalError;
import ch.powerunit.impl.validator.ParameterValidator;
import ch.powerunit.impl.validator.ParametersValidator;
import ch.powerunit.impl.validator.RuleValidator;
import ch.powerunit.impl.validator.TestValidator;

public class DefaultPowerUnitRunnerImpl&lt;T&gt; implements PowerUnitRunner&lt;T&gt;,
		ParametersValidator, ParameterValidator, TestValidator, RuleValidator {

<span class="fc" id="L58">	private final List&lt;TestResultListener&lt;Object&gt;&gt; listeners = new ArrayList&lt;&gt;();</span>

	private final String parentGroups;

	private final T targetObject;

	private final String setName;

<span class="fc" id="L66">	public DefaultPowerUnitRunnerImpl(Class&lt;T&gt; testClass) {</span>
<span class="fc" id="L67">		Objects.requireNonNull(testClass);</span>

<span class="fc" id="L69">		this.setName = testClass.getName();</span>
<span class="fc" id="L70">		Set&lt;String&gt; groups = findClass(testClass)</span>
<span class="fc" id="L71">				.stream()</span>
<span class="fc" id="L72">				.filter(c -&gt; c.isAnnotationPresent(Categories.class))</span>
<span class="fc" id="L73">				.map(c -&gt; Arrays.stream(</span>
						c.getAnnotation(Categories.class).value()).collect(
						Collectors.toCollection(() -&gt; new HashSet&lt;&gt;())))
<span class="fc" id="L76">				.reduce((o, n) -&gt; {</span>
					o.addAll(n);
					return o;
<span class="fc" id="L79">				}).orElse(new HashSet&lt;&gt;());</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">		this.parentGroups = groups.isEmpty() ? TestResultListener.ALL_GROUPS</span>
<span class="fc" id="L81">				: Arrays.toString(groups.toArray());</span>

		try {
<span class="fc" id="L84">			targetObject = testClass.newInstance();</span>
<span class="fc" id="L85">		} catch (InstantiationException | IllegalAccessException e) {</span>
<span class="fc" id="L86">			throw new InternalError(&quot;Unexpected error &quot; + e.getMessage(), e);</span>
<span class="fc" id="L87">		}</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">		if (testClass.isAnnotationPresent(Ignore.class)) {</span>
<span class="fc" id="L90">			executableTests.put(setName, p -&gt; {</span>
				TestContextImpl&lt;Object&gt; ctx = new TestContextImpl&lt;&gt;(
						targetObject, setName, setName, null, parentGroups);
				notifyStartTest(ctx);
				notifyEndSkippedTest(ctx);
			});
<span class="fc" id="L96">			return;</span>
		}
<span class="fc" id="L98">		findTestsMethod(targetObject, testClass, parentGroups);</span>
<span class="fc" id="L99">		findTestsRule(targetObject, testClass);</span>
<span class="fc" id="L100">		findParametersMethod(targetObject, testClass);</span>
<span class="fc" id="L101">		computeExecutableStatements();</span>
<span class="fc" id="L102">	}</span>

	@Override
	public void run() {
<span class="fc" id="L106">		notifyStartTests(setName, parentGroups);</span>
		try {
<span class="fc bfc" id="L108" title="All 2 branches covered.">			if (parameters != null) {</span>
<span class="fc" id="L109">				runAll();</span>
			} else {
<span class="fc" id="L111">				runOne(null);</span>
			}
		} finally {
<span class="pc" id="L114">			notifyEndTests(setName, parentGroups);</span>
<span class="fc" id="L115">		}</span>

<span class="fc" id="L117">	}</span>

	private void runAll() {
<span class="fc" id="L120">		testIndex = 0;</span>
<span class="pc" id="L121">		try (Stream&lt;?&gt; params = (Stream&lt;?&gt;) parameters.invoke(targetObject)) {</span>
<span class="fc" id="L122">			params.forEach(this::runOneParameter);</span>
<span class="pc bpc" id="L123" title="6 of 8 branches missed.">		} catch (IllegalAccessException | IllegalArgumentException</span>
				| InvocationTargetException e) {
<span class="nc" id="L125">			throw new InternalError(&quot;Unexpected error &quot; + e.getMessage(), e);</span>
<span class="fc" id="L126">		}</span>
<span class="fc" id="L127">	}</span>

<span class="fc" id="L129">	private int testIndex = 0;</span>

	private void runOneParameter(Object op) {
<span class="fc" id="L132">		String formatter = parameters.getAnnotation(Parameters.class).value();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">		if (&quot;&quot;.equals(formatter)) {</span>
<span class="fc" id="L134">			formatter = &quot;&quot; + testIndex;</span>
		}
		Object o[];
<span class="pc bpc" id="L137" title="1 of 4 branches missed.">		if (op != null &amp;&amp; op.getClass().isArray()) {</span>
<span class="fc" id="L138">			o = (Object[]) op;</span>
		} else {
<span class="fc" id="L140">			o = new Object[] { op };</span>
		}
<span class="fc" id="L142">		String name = MessageFormat.format(formatter, o);</span>
<span class="fc" id="L143">		int pidx = 0;</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		if (o.length != parameterFields.size()) {</span>
<span class="nc" id="L145">			throw new InternalError(</span>
					&quot;Parameter fields count doesn't match with array size returned by parameters&quot;);
		}
<span class="fc bfc" id="L148" title="All 2 branches covered.">		for (Object p : o) {</span>
			try {
<span class="fc" id="L150">				Field f = parameterFields.get(pidx);</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">				if (f == null) {</span>
<span class="nc" id="L152">					throw new InternalError(&quot;Field &quot; + pidx + &quot; is not found&quot;);</span>
				}
<span class="fc" id="L154">				f.set(targetObject, p);</span>
<span class="nc" id="L155">			} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L156">				throw new InternalError(&quot;Unexpected error &quot; + e.getMessage(), e);</span>
<span class="fc" id="L157">			}</span>
<span class="fc" id="L158">			pidx++;</span>
		}
<span class="fc" id="L160">		runOne(name);</span>
<span class="fc" id="L161">		testIndex++;</span>
<span class="fc" id="L162">	}</span>

	private void runOne(String name) {
<span class="fc" id="L165">		executableTests.entrySet().forEach(</span>
				singleTest -&gt; {
					try {
						singleTest.getValue().run(
								new TestContextImpl&lt;Object&gt;(targetObject,
										setName, singleTest.getKey(), name,
										parentGroups));
					} catch (Throwable e) {// NOSONAR
						// As we really want all error
						throw new InternalError(&quot;Unexpected error &quot;
								+ e.getMessage(), e);
					}
				});
<span class="fc" id="L178">	}</span>

<span class="fc" id="L180">	private final Map&lt;String, Method&gt; testMethods = new HashMap&lt;&gt;();</span>

<span class="fc" id="L182">	private TestRule testRules = null;</span>

<span class="fc" id="L184">	private Map&lt;String, Statement&lt;TestContext&lt;Object&gt;, Throwable&gt;&gt; executableTests = new HashMap&lt;&gt;();</span>

<span class="fc" id="L186">	private Method parameters = null;</span>

	private Map&lt;Integer, Field&gt; parameterFields;

	private void findParametersMethod(T targetObject, Class&lt;T&gt; testClass) {
<span class="fc" id="L191">		parameters = Arrays</span>
<span class="fc" id="L192">				.stream(testClass.getDeclaredMethods())</span>
<span class="fc" id="L193">				.filter(m -&gt; m.isAnnotationPresent(Parameters.class))</span>
<span class="fc" id="L194">				.peek(m -&gt; checkParametersAnnotationForMethod(m))</span>
<span class="fc" id="L195">				.reduce((o, n) -&gt; {</span>
					throw new InternalError(
							&quot;@Parameters method can't only be once&quot;);
<span class="fc" id="L198">				}).orElse(null);</span>
<span class="fc" id="L199">		parameterFields = Arrays</span>
<span class="fc" id="L200">				.stream(testClass.getDeclaredFields())</span>
<span class="fc" id="L201">				.filter(f -&gt; f.isAnnotationPresent(Parameter.class))</span>
<span class="fc" id="L202">				.peek(f -&gt; {</span>
					if (parameters == null) {
						throw new InternalError(
								&quot;@Parameter can't be used without @Parameters method&quot;);
					}
				})
<span class="fc" id="L208">				.peek(f -&gt; checkParameterAnnotationForField(f))</span>
<span class="fc" id="L209">				.collect(</span>
						Collectors
<span class="fc" id="L211">								.&lt;Field, Integer, Field&gt; toMap(</span>
										(Field f) -&gt; f.getAnnotation(
												Parameter.class).value(),
										(Field f) -&gt; f,
										(f1, f2) -&gt; {
											throw new InternalError(
													&quot;@Parameter can't be used twice with the same value number&quot;);
										}));
<span class="fc bfc" id="L219" title="All 2 branches covered.">		if (parameters != null) {</span>
			// assuming field numbering 0 to
<span class="fc" id="L221">			int size = parameterFields.size();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">			if (size == 0) {</span>
<span class="fc" id="L223">				throw new InternalError(&quot;No @Parameter field found&quot;);</span>
			}
<span class="fc" id="L225">			int expected = (size * (size - 1)) / 2;</span>
<span class="fc" id="L226">			int sum = parameterFields.keySet().stream().mapToInt(i -&gt; i).sum();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (sum != expected) {</span>
<span class="fc" id="L228">				throw new InternalError(</span>
						&quot;@Parameter field number aren't continuus&quot;);
			}
		}
<span class="fc" id="L232">	}</span>

	private void findTestsMethod(T targetObject, Class&lt;T&gt; testClass,
			String parentGroup) {
<span class="fc" id="L236">		findClass(testClass).forEach(</span>
				cls -&gt; {
					Arrays.stream(cls.getDeclaredMethods())
							.filter(m -&gt; m.isAnnotationPresent(Test.class))
							.forEach(m -&gt; {
								checkTestAnnotationForMethod(m);
								Test annotation = m.getAnnotation(Test.class);
								String testName = m.getName();
								if (!&quot;&quot;.equals(annotation.name())) {
									testName = annotation.name();
								}
								testMethods.put(testName, m);
							});
				});
<span class="fc" id="L250">	}</span>

	private void findTestsRule(T targetObject, Class&lt;T&gt; testClass) {
<span class="fc" id="L253">		testRules = findClass(testClass)</span>
<span class="fc" id="L254">				.stream()</span>
<span class="fc" id="L255">				.map(cls -&gt; Arrays</span>
						.stream(cls.getDeclaredFields())
						.filter(f -&gt; f.isAnnotationPresent(Rule.class))
						.map(f -&gt; {
							checkRuleAnnotationForField(f);
							try {
								TestRule tr1 = (TestRule) f.get(targetObject);
								if (tr1 == null) {
									throw new InternalError(
											&quot;@Rule annotation is used on a null field. This is not allowed&quot;);
								}
								return tr1;
							} catch (IllegalAccessException
									| IllegalArgumentException e) {
								throw new InternalError(&quot;Unexpected error &quot;
										+ e.getMessage(), e);
							}
						})
						.reduce((o, n) -&gt; {
							throw new InternalError(
									&quot;@Rule annotation can only be used once on field&quot;);
<span class="fc" id="L276">						}).orElse(null)).filter(i -&gt; i != null)</span>
<span class="fc" id="L277">				.reduce((o, n) -&gt; o.around(n)).orElse(null);</span>

<span class="fc" id="L279">	}</span>

	private List&lt;Class&lt;?&gt;&gt; findClass(Class&lt;T&gt; testClass) {
<span class="fc" id="L282">		List&lt;Class&lt;?&gt;&gt; clazzs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L283">		Class&lt;?&gt; current = testClass;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">		while (current != null) {</span>
<span class="fc" id="L285">			clazzs.add(0, current);</span>
<span class="fc" id="L286">			current = current.getSuperclass();</span>
		}
<span class="fc" id="L288">		return clazzs;</span>
	}

	private void computeExecutableStatements() {
<span class="fc" id="L292">		executableTests = testMethods</span>
<span class="fc" id="L293">				.entrySet()</span>
<span class="fc" id="L294">				.stream()</span>
<span class="fc" id="L295">				.collect(</span>
<span class="fc" id="L296">						Collectors.toMap(</span>
								test -&gt; test.getKey(),
								test -&gt; {
									Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; stest;
									if (test.getValue().isAnnotationPresent(
											Ignore.class)) {
										stest = p -&gt; {
											throw new AssumptionError(
													&quot;Test method is annotated with @Ignore&quot;);
										};
									} else {
										Statement&lt;TestContext&lt;Object&gt;, Throwable&gt; itest = p -&gt; {
											Statement
													.&lt;TestContext&lt;Object&gt;, Throwable&gt; reflectionMethod(
															targetObject,
															test.getValue())
													.run(p);
										};
										if (testRules != null) {
											stest = p -&gt; testRules
													.computeStatement(itest)
													.run(p);
										} else {
											stest = itest;
										}

									}
									return p -&gt; {
										notifyStartTest(p);
										try {
											stest.run(p);
											notifyEndSuccessTest(p);
										} catch (InternalError e) {
											notifyEndFailureTest(p, e);
										} catch (AssertionError e) {
											notifyEndFailureTest(p, e);
										} catch (AssumptionError e) {
											notifyEndSkippedTest(p);
										} catch (Throwable e) {// NOSONAR
											// As we really want all error
											notifyEndFailureTest(p, e);
										}
									};
								}));
<span class="fc" id="L340">	}</span>

	@Override
	public void addListener(TestResultListener&lt;T&gt; listener) {
<span class="fc" id="L344">		listeners.add((TestResultListener) listener);</span>
<span class="fc" id="L345">	}</span>

	private void notifyStartTests(String setName, String groups) {
<span class="fc" id="L348">		listeners.forEach(trl -&gt; trl.notifySetStart(setName, groups));</span>
<span class="fc" id="L349">	}</span>

	private void notifyEndTests(String setName, String groups) {
<span class="fc" id="L352">		listeners.forEach(trl -&gt; trl.notifySetEnd(setName, groups));</span>
<span class="fc" id="L353">	}</span>

	private void notifyStartTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L356">		listeners.forEach(trl -&gt; trl.notifyStart(context));</span>
<span class="fc" id="L357">	}</span>

	private void notifyEndSuccessTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L360">		listeners.forEach(trl -&gt; trl.notifySuccess(context));</span>
<span class="fc" id="L361">	}</span>

	private void notifyEndSkippedTest(TestContext&lt;Object&gt; context) {
<span class="fc" id="L364">		listeners.forEach(trl -&gt; trl.notifySkipped(context));</span>
<span class="fc" id="L365">	}</span>

	private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
			AssertionError cause) {
<span class="fc" id="L369">		listeners.forEach(trl -&gt; trl.notifyFailure(context, cause));</span>
<span class="fc" id="L370">	}</span>

	private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
			InternalError cause) {
<span class="nc" id="L374">		listeners.forEach(trl -&gt; trl.notifyError(context, cause));</span>
<span class="nc" id="L375">	}</span>

	private void notifyEndFailureTest(TestContext&lt;Object&gt; context,
			Throwable cause) {
<span class="fc" id="L379">		listeners.forEach(trl -&gt; trl.notifyError(context, cause));</span>
<span class="fc" id="L380">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>